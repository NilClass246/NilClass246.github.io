(function(){"use strict";var n={2706:function(n,t,e){var o=e(9242),i=e(3396);function r(n,t,e,o,r,a){const s=(0,i.up)("BlogHeader"),c=(0,i.up)("BlogCanvas"),d=(0,i.up)("BlogInfo");return(0,i.wg)(),(0,i.iD)(i.HY,null,[(0,i.Wm)(s,{title:"今日着色器 | Today's Shader"}),(0,i.Wm)(c),(0,i.Wm)(d)],64)}var a=e(7139);const s={id:"outer_header"},c={id:"inner_header"};function d(n,t,e,o,r,d){return(0,i.wg)(),(0,i.iD)("div",s,[(0,i._)("div",c,(0,a.zw)(e.title),1)])}var f={name:"BlogHeader",props:{title:String}},l=e(89);const v=(0,l.Z)(f,[["render",d],["__scopeId","data-v-3a93e98e"]]);var u=v;const m={id:"canvas_container"},p={ref:"canvas",id:"main_canvas"};function h(n,t,e,o,r,a){return(0,i.wg)(),(0,i.iD)("div",m,[(0,i._)("canvas",p,null,512)])}e(8675),e(7380),e(1118);var g=e(1839),x={name:"BlogCanvas",data(){return{vertexShaderSource:"#version 300 es\n \n                // an attribute is an input (in) to a vertex shader.\n                // It will receive data from a buffer\n                in vec4 a_position;\n                \n                // all shaders have a main function\n                void main() {\n                \n                // gl_Position is a special variable a vertex shader\n                // is responsible for setting\n                gl_Position = a_position;\n                }",fragmentShaderSource:"#version 300 es\n                precision highp float;\n \n                uniform vec2 iResolution;\n                uniform vec2 iMouse;\n                uniform float iTime;\n                uniform vec4 iDate;\n\n                \x3c!-- insert here --\x3e\n                \n                out vec4 outColor;\n                void main() {\n                    mainImage(outColor, gl_FragCoord.xy);\n                }\n                ",SaturdayTorus:"\n                // License CC0: Saturday Torus\n                //  Inspired by: https://www.istockphoto.com/photo/black-and-white-stripes-projection-on-torus-gm488221403-39181884\n\n                #define PI          3.141592654\n                #define TAU         (2.0*PI)\n                #define TIME        iTime\n                #define TTIME       (TAU*TIME)\n                #define RESOLUTION  iResolution\n                #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n                #define PCOS(x)     (0.5+0.5*cos(x))\n\n                // License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors\n                float rayTorus(vec3 ro, vec3 rd, vec2 tor) {\n                  float po = 1.0;\n\n                  float Ra2 = tor.x*tor.x;\n                  float ra2 = tor.y*tor.y;\n\n                  float m = dot(ro,ro);\n                  float n = dot(ro,rd);\n\n                  // bounding sphere\n                  {\n                    float h = n*n - m + (tor.x+tor.y)*(tor.x+tor.y);\n                    if(h<0.0) return -1.0;\n                    //float t = -n-sqrt(h); // could use this to compute intersections from ro+t*rd\n                  }\n\n                  // find quartic equation\n                  float k = (m - ra2 - Ra2)/2.0;\n                  float k3 = n;\n                  float k2 = n*n + Ra2*rd.z*rd.z + k;\n                  float k1 = k*n + Ra2*ro.z*rd.z;\n                  float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\n                  #ifndef TORUS_REDUCE_PRECISION\n                  // prevent |c1| from being too close to zero\n                  if(abs(k3*(k3*k3 - k2) + k1) < 0.01)\n                  {\n                    po = -1.0;\n                    float tmp=k1; k1=k3; k3=tmp;\n                    k0 = 1.0/k0;\n                    k1 = k1*k0;\n                    k2 = k2*k0;\n                    k3 = k3*k0;\n                  }\n                  #endif\n\n                  float c2 = 2.0*k2 - 3.0*k3*k3;\n                  float c1 = k3*(k3*k3 - k2) + k1;\n                  float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n\n\n                  c2 /= 3.0;\n                  c1 *= 2.0;\n                  c0 /= 3.0;\n\n                  float Q = c2*c2 + c0;\n                  float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n\n                  float h = R*R - Q*Q*Q;\n                  float z = 0.0;\n                  if(h < 0.0) {\n                    // 4 intersections\n                    float sQ = sqrt(Q);\n                    z = 2.0*sQ*cos(acos(R/(sQ*Q)) / 3.0);\n                  } else {\n                    // 2 intersections\n                    float sQ = pow(sqrt(h) + abs(R), 1.0/3.0);\n                    z = sign(R)*abs(sQ + Q/sQ);\n                  }\n                  z = c2 - z;\n\n                  float d1 = z   - 3.0*c2;\n                  float d2 = z*z - 3.0*c0;\n                  if(abs(d1) < 1.0e-4) {\n                    if(d2 < 0.0) return -1.0;\n                    d2 = sqrt(d2);\n                  } else {\n                    if(d1 < 0.0) return -1.0;\n                    d1 = sqrt(d1/2.0);\n                    d2 = c1/d1;\n                  }\n\n                  //----------------------------------\n\n                  float result = 1e20;\n\n                  h = d1*d1 - z + d2;\n                  if(h > 0.0) {\n                    h = sqrt(h);\n                    float t1 = -d1 - h - k3; t1 = (po<0.0)?2.0/t1:t1;\n                    float t2 = -d1 + h - k3; t2 = (po<0.0)?2.0/t2:t2;\n                    if(t1 > 0.0) result=t1;\n                    if(t2 > 0.0) result=min(result,t2);\n                  }\n\n                  h = d1*d1 - z - d2;\n                  if(h > 0.0) {\n                    h = sqrt(h);\n                    float t1 = d1 - h - k3;  t1 = (po<0.0)?2.0/t1:t1;\n                    float t2 = d1 + h - k3;  t2 = (po<0.0)?2.0/t2:t2;\n                    if(t1 > 0.0) result=min(result,t1);\n                    if(t2 > 0.0) result=min(result,t2);\n                  }\n\n                  return result;\n                }\n\n                // License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors\n                vec3 torusNormal(vec3 pos, vec2 tor) {\n                  return normalize(pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n                }\n\n                // License: Unknown, author: Unknown, found: don't remember\n                float tanh_approx(float x) {\n                  //  Found this somewhere on the interwebs\n                  //  return tanh(x);\n                  float x2 = x*x;\n                  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n                }\n\n                vec3 color(vec2 p, vec2 q) {\n                  const float rdd = 2.0;\n                  vec3 ro  = 1.*vec3(0., 0.75, -0.2);\n                  vec3 la  = vec3(0.0, 0.0, 0.2);\n                  vec3 up  = vec3(0.3, 0.0, 1.0);\n                  vec3 lp1 = ro;\n                  lp1.xy  *= ROT(0.85);\n                  lp1.xz  *= ROT(-0.5);\n\n                  vec3 ww = normalize(la - ro);\n                  vec3 uu = normalize(cross(up, ww));\n                  vec3 vv = normalize(cross(ww,uu));\n                  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n\n                  const vec2 tor = 0.55*vec2(1.0, 0.75);\n                  float td    = rayTorus(ro, rd, tor);\n                  vec3  tpos  = ro + rd*td;\n                  vec3  tnor  = -torusNormal(tpos, tor);\n                  vec3  tref  = reflect(rd, tnor);\n\n                  vec3  ldif1 = lp1 - tpos;\n                  float ldd1  = dot(ldif1, ldif1);\n                  float ldl1  = sqrt(ldd1);\n                  vec3  ld1   = ldif1/ldl1;\n                  vec3  sro   = tpos+0.05*tnor;\n                  float sd    = rayTorus(sro, ld1, tor);\n                  vec3  spos  = sro+ld1*sd;\n                  vec3  snor  = -torusNormal(spos, tor);\n\n                  float dif1  = max(dot(tnor, ld1), 0.0);\n                  float spe1  = pow(max(dot(tref, ld1), 0.0), 10.0);\n                  float r     = length(tpos.xy);\n                  float a     = atan(tpos.y, tpos.x)-PI*tpos.z/(r+0.5*abs(tpos.z))-TTIME/45.0;\n                  float s     = mix(0.05, 0.5, tanh_approx(2.0*abs(td-0.75)));\n                  vec3  bcol0 = vec3(0.3);  \n                  vec3  bcol1 = vec3(0.025);  \n                  vec3  tcol  = mix(bcol0, bcol1, smoothstep(-s, s, sin(9.0*a)));\n\n                  vec3 col = vec3(0.0);\n\n                  if (td > -1.0) {\n                    col += tcol*mix(0.2, 1.0, dif1/ldd1)+0.25*spe1;\n                    col *= sqrt(abs(dot(rd, tnor)));\n                  }\n                  \n                  if (sd < ldl1) {\n                    col *= mix(1.0, 0.0, pow(abs(dot(ld1, snor)), 3.0*tanh_approx(sd)));\n                  }\n\n                  return col;\n                }\n\n                // License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/index.htm\n                vec3 postProcess(vec3 col, vec2 q) {\n                  col = clamp(col, 0.0, 1.0);\n                  col = pow(col, 1.0/vec3(2.2));\n                  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n                  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n                  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n                  return col;\n                }\n\n                void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n                  vec2 q = fragCoord/iResolution.xy;\n                  vec2 p = -1. + 2. * q;\n                  p.x *= RESOLUTION.x/RESOLUTION.y;\n                  vec3 col = color(p, q);\n                  col = postProcess(col, q);\n                  fragColor = vec4(col, 1.0);\n                }",NixieTubeClock:'\n                #define TWELVE_HOUR_CLOCK   1\n                #define GLOWPULSE    1\n                #define SHOW_GRID\n\n                float pi = atan(1.0)*4.0;\n                float tau = atan(1.0)*8.0;\n\n                const float scale = 1.0 / 6.0;\n\n                vec2 digitSize = vec2(1.0,1.5) * scale;\n                vec2 digitSpacing = vec2(1.1,1.6) * scale;\n\n\n\n                // hash function copy from https://www.shadertoy.com/view/4djSRW\n                float hash12(vec2 p)\n                {\n                    vec3 p3  = fract(vec3(p.xyx) * .1031);\n                    p3 += dot(p3, p3.yzx + 33.33);\n                    return fract((p3.x + p3.y) * p3.z);\n                }\n\n\n                float noise(vec2 pos) {\n                    vec2 i = floor(pos);\n                    vec2 f = fract(pos);\n                    \n                    float a = hash12(i);\n                    float b = hash12(i + vec2(1, 0));\n                    float c = hash12(i + vec2(0, 1));\n                    float d = hash12(i + vec2(1, 1));\n\n                    vec2 u = f * f * (3.0 - 2.0 * f);\n\n                    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n                }\n\n                //Distance to a line segment,\n                float dfLine(vec2 start, vec2 end, vec2 uv)\n                {\n                  start *= scale;\n                  end *= scale;\n                    \n                  vec2 line = end - start;\n                  float frac = dot(uv - start,line) / dot(line,line);\n                  return distance(start + line * clamp(frac, 0.0, 1.0), uv);\n                }\n\n                //Distance to the edge of a circle.\n                float dfCircle(vec2 origin, float radius, vec2 uv)\n                {\n                  origin *= scale;\n                  radius *= scale;\n                    \n                  return abs(length(uv - origin) - radius);\n                }\n\n                //Distance to an arc.\n                float dfArc(vec2 origin, float start, float sweep, float radius, vec2 uv)\n                {\n                  origin *= scale;\n                  radius *= scale;\n                    \n                  uv -= origin;\n                  uv *= mat2(cos(start), sin(start),-sin(start), cos(start));\n                  \n                  float offs = (sweep / 2.0 - pi);\n                  float ang = mod(atan(uv.y, uv.x) - offs, tau) + offs;\n                  ang = clamp(ang, min(0.0, sweep), max(0.0, sweep));\n                  \n                  return distance(radius * vec2(cos(ang), sin(ang)), uv);\n                }\n\n                //Distance to the digit "d" (0-9).\n                float dfDigit(vec2 origin, float d, vec2 uv)\n                {\n                  uv -= origin;\n                  d = floor(d);\n                  float dist = 1e6;\n                  \n                  if(d == 0.0)\n                  {\n                    dist = min(dist, dfLine(vec2(1.000,1.000), vec2(1.000,0.500), uv));\n                    dist = min(dist, dfLine(vec2(0.000,1.000), vec2(0.000,0.500), uv));\n                    dist = min(dist, dfArc(vec2(0.500,1.000),0.000, 3.142, 0.500, uv));\n                    dist = min(dist, dfArc(vec2(0.500,0.500),3.142, 3.142, 0.500, uv));\n                    return dist;\n                  }\n                  if(d == 1.0)\n                  {\n                    dist = min(dist, dfLine(vec2(0.500,1.500), vec2(0.500,0.000), uv));\n                    return dist;\n                  }\n                  if(d == 2.0)\n                  {\n                    dist = min(dist, dfLine(vec2(1.000,0.000), vec2(0.000,0.000), uv));\n                    dist = min(dist, dfLine(vec2(0.388,0.561), vec2(0.806,0.719), uv));\n                    dist = min(dist, dfArc(vec2(0.500,1.000),0.000, 3.142, 0.500, uv));\n                    dist = min(dist, dfArc(vec2(0.700,1.000),5.074, 1.209, 0.300, uv));\n                    dist = min(dist, dfArc(vec2(0.600,0.000),1.932, 1.209, 0.600, uv));\n                    return dist;\n                  }\n                  if(d == 3.0)\n                  {\n                    dist = min(dist, dfLine(vec2(0.000,1.500), vec2(1.000,1.500), uv));\n                    dist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.500,1.000), uv));\n                    dist = min(dist, dfArc(vec2(0.500,0.500),3.142, 4.712, 0.500, uv));\n                    return dist;\n                  }\n                  if(d == 4.0)\n                  {\n                    dist = min(dist, dfLine(vec2(0.700,1.500), vec2(0.000,0.500), uv));\n                    dist = min(dist, dfLine(vec2(0.000,0.500), vec2(1.000,0.500), uv));\n                    dist = min(dist, dfLine(vec2(0.700,1.200), vec2(0.700,0.000), uv));\n                    return dist;\n                  }\n                  if(d == 5.0)\n                  {\n                    dist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.300,1.500), uv));\n                    dist = min(dist, dfLine(vec2(0.300,1.500), vec2(0.200,0.900), uv));\n                    dist = min(dist, dfArc(vec2(0.500,0.500),3.142, 5.356, 0.500, uv));\n                    return dist;\n                  }\n                  if(d == 6.0)\n                  {\n                    dist = min(dist, dfLine(vec2(0.067,0.750), vec2(0.500,1.500), uv));\n                    dist = min(dist, dfCircle(vec2(0.500,0.500), 0.500, uv));\n                    return dist;\n                  }\n                  if(d == 7.0)\n                  {\n                    dist = min(dist, dfLine(vec2(0.000,1.500), vec2(1.000,1.500), uv));\n                    dist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.500,0.000), uv));\n                    return dist;\n                  }\n                  if(d == 8.0)\n                  {\n                    dist = min(dist, dfCircle(vec2(0.500,0.400), 0.400, uv));\n                    dist = min(dist, dfCircle(vec2(0.500,1.150), 0.350, uv));\n                    return dist;\n                  }\n                  if(d == 9.0)\n                  {\n                    dist = min(dist, dfLine(vec2(0.933,0.750), vec2(0.500,0.000), uv));\n                    dist = min(dist, dfCircle(vec2(0.500,1.000), 0.500, uv));\n                    return dist;\n                  }\n\n                  return dist;\n                }\n\n                //Distance to a number\n                float dfNumber(vec2 origin, float num, vec2 uv)\n                {\n                  uv -= origin;\n                  float dist = 1e6;\n                  float offs = 0.0;\n                  \n                  for(float i = 5.0;i > -3.0;i--)\n                  {\t\n                    float d = mod(num / pow(10.0,i),10.0);\n                    \n                    vec2 pos = digitSpacing * vec2(offs,0.0);\n\n                    if(i == 0.0)\n                    {\n                      dist = min(dist, dfCircle(vec2(offs+0.9,0.1)*1.1, 0.04,uv));\n                    }\n                    \n                    if(num > pow(10.0,i) || i == 0.0)\n                    {\n                      dist = min(dist, dfDigit(pos, d, uv));\n                      offs++;\n                    }\t\n                  }\n                  return dist;\t\n                }\n\n                //Distance to a number This handles 2 digit integers, leading 0\'s will be drawn\n                float dfNumberInt(vec2 origin, int inum, vec2 uv)\n                {\n                    float num = float(inum);\n                  uv -= origin;\n                  float dist = 1e6;\n                  float offs = 0.0;\n                  \n                  for(float i = 1.0;i >= 0.0;i--)\n                  {\t\n                    float d = mod(num / pow(10.0,i),10.0);\n                    \n                    vec2 pos = digitSpacing * vec2(offs,0.0);\n                    \n                        dist = min(dist, dfDigit(pos, d, uv));\n                        offs++;\n                  }\n                  return dist;\t\n                }\n\n                float dfColon(vec2 origin, vec2 uv) {\n                  uv -= origin;\n                  float dist = 1e6;\n                  float offs = 0.0;\n\n                    dist = min(dist, dfCircle(vec2(offs+0.9,0.9)*1.1, 0.04,uv));\n                    dist = min(dist, dfCircle(vec2(offs+0.9,0.4)*1.1, 0.04,uv));\n                    return dist;\n                }\n\n                //Length of a number in digits\n                float numberLength(float n)\n                {\n                  return floor(max(log(n) / log(10.0), 0.0) + 1.0) + 2.0;\n                }\n\n                void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n                {\n                  // Test outside the circle for round watches\n                  /*vec2 uvTest = (gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\n                  float absX = uvTest.x*uvTest.x;\n                  float absY = uvTest.y*uvTest.y;\n                  if(sqrt(absX + absY) >0.5) {\n                    fragColor = vec4(0.1);\n                    return;\n                  }*/\n                  // end test\n                  \n                  vec2 aspect = iResolution.xy / iResolution.y;\n                  vec2 uv = (fragCoord.xy / iResolution.y - aspect/2.0) *0.86;\n                  \n                    \n                    int hour = int(iDate.w/3600.);\n                #if TWELVE_HOUR_CLOCK\n                    if( hour > 12 ) hour -= 12;\n                    if( hour == 0 ) hour = 12;\n                #endif\n                    int minute = int(mod(iDate.w/60.,60.));\n                    \n                  float nsize = numberLength(9999.);\n                  vec2 pos = -digitSpacing * vec2(nsize,1.0)/2.0;\n\n                    vec2 basepos = pos;\n                    pos.x = basepos.x + 0.16;\n                  float dist = 1e6;\n                  dist = min(dist, dfNumberInt(pos, hour, uv));\n                    \n                    pos.x = basepos.x + 0.39;\n                  dist = min(dist, dfColon( pos, uv ));\n                    \n                    pos.x = basepos.x + 0.60;\n                    float dist2 = 1e6;\n                  dist = min(dist, dfNumberInt(pos, minute, uv));\n                  \n                  vec3 color = vec3(0);\n                  \n                  float shade = 0.0;\n                  \n                  shade = 0.004 / (dist);\n                  \n                  color += vec3(1,0.2,0) * shade;\n                #if GLOWPULSE\n                  color += vec3(1,0.2,0) * shade * noise((uv + vec2(iTime*.5)) * 2.5 + .5);// * 10.*(noise(uv.yx));\n                #endif\n\n                    #ifdef SHOW_GRID\n                    float grid = 0.5-max(abs(mod(uv.x*64.0,1.0)-0.5), abs(mod(uv.y*64.0,1.0)-0.5));\n                    \n                    color *= 0.25+vec3(smoothstep(0.0,64.0 / iResolution.y,grid))*0.75;\n                    #endif\n                  \n                  fragColor = vec4( color , 1.0 );\n                }'}},mounted(){this.initialize()},methods:{initialize(){console.log("initialized");var n=this.$refs.canvas,t=n.getContext("webgl2");t||console.log("webgl not supported");var e=this.vertexShaderSource,o=this.fragmentShaderSource.replace("\x3c!-- insert here --\x3e",this.NixieTubeClock);const i=g.jr(t,[e,o]);var r=t.getAttribLocation(i,"a_position");const a=t.getUniformLocation(i,"iResolution"),s=t.getUniformLocation(i,"iMouse"),c=t.getUniformLocation(i,"iTime"),d=t.getUniformLocation(i,"iDate");var f=t.createVertexArray();t.bindVertexArray(f);var l=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,l),t.bufferData(t.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),t.STATIC_DRAW),t.enableVertexAttribArray(r);var v=2,u=t.FLOAT,m=!1,p=0,h=0;t.vertexAttribPointer(r,v,u,m,p,h),g.Lo(t.canvas),t.viewport(0,0,t.canvas.width,t.canvas.height);const x=document.querySelector("#canvas_container");let b=0,w=0;function y(n){const t=x.getBoundingClientRect();b=n.clientX-t.left,w=t.height-(n.clientY-t.top)-1}x.addEventListener("mousemove",y),x.addEventListener("touchstart",(n=>{n.preventDefault()}),{passive:!1}),x.addEventListener("touchmove",(n=>{n.preventDefault(),y(n.touches[0])}),{passive:!1}),x.addEventListener("touchend",(n=>{n.preventDefault()}),{passive:!1});let k=0,L=0;const T=(new Date).setHours(0,0,0,0);function S(n){n*=.001;const e=Math.min(n-k,.1);L+=e,k=n,g.Lo(t.canvas),t.viewport(0,0,t.canvas.width,t.canvas.height),t.useProgram(i),t.bindVertexArray(f),t.uniform2f(a,t.canvas.width,t.canvas.height),t.uniform2f(s,b,w),t.uniform1f(c,L);let o=new Date;t.uniform4f(d,0,0,0,(o-T)/1e3),t.drawArrays(t.TRIANGLES,0,6),requestAnimationFrame(S)}requestAnimationFrame(S)},createShader(n,t,e){var o=n.createShader(t);n.shaderSource(o,e),n.compileShader(o);var i=n.getShaderParameter(o,n.COMPILE_STATUS);if(i)return o;console.log(n.getShaderInfoLog(o)),n.deleteShader(o)},createProgram(n,t,e){var o=n.createProgram();n.attachShader(o,t),n.attachShader(o,e),n.linkProgram(o);var i=n.getProgramParameter(o,n.LINK_STATUS);if(i)return o;console.log(n.getProgramInfoLog(o)),n.deleteProgram(o)}}};const b=(0,l.Z)(x,[["render",h],["__scopeId","data-v-6dbf87a8"]]);var w=b;const y={id:"info_container"},k=["innerHTML"];function L(n,t,e,o,r,a){return(0,i.wg)(),(0,i.iD)("div",y,[(0,i._)("div",{id:"info_content",innerHTML:r.content2},null,8,k)])}var T={data(){return{content1:"来自ShaderToy的美丽螺旋<br><br>Saturday Torus <br> Created By mrange <br> <a href='https://www.shadertoy.com/view/fd33zn'>https://www.shadertoy.com/view/fd33zn</a>",content2:"来自ShaderToy的辉光管时钟<br><br>Nixie Tube Clock <br> Created By timmaffett & picoplanetdev <br> <a href='https://www.shadertoy.com/view/Dds3WB'>https://www.shadertoy.com/view/Dds3WB</a>"}}};const S=(0,l.Z)(T,[["render",L],["__scopeId","data-v-3bed3360"]]);var C=S,R={name:"App",components:{BlogHeader:u,BlogCanvas:w,BlogInfo:C}};const z=(0,l.Z)(R,[["render",r]]);var _=z;(0,o.ri)(_).mount("#app")}},t={};function e(o){var i=t[o];if(void 0!==i)return i.exports;var r=t[o]={exports:{}};return n[o](r,r.exports,e),r.exports}e.m=n,function(){var n=[];e.O=function(t,o,i,r){if(!o){var a=1/0;for(f=0;f<n.length;f++){o=n[f][0],i=n[f][1],r=n[f][2];for(var s=!0,c=0;c<o.length;c++)(!1&r||a>=r)&&Object.keys(e.O).every((function(n){return e.O[n](o[c])}))?o.splice(c--,1):(s=!1,r<a&&(a=r));if(s){n.splice(f--,1);var d=i();void 0!==d&&(t=d)}}return t}r=r||0;for(var f=n.length;f>0&&n[f-1][2]>r;f--)n[f]=n[f-1];n[f]=[o,i,r]}}(),function(){e.n=function(n){var t=n&&n.__esModule?function(){return n["default"]}:function(){return n};return e.d(t,{a:t}),t}}(),function(){e.d=function(n,t){for(var o in t)e.o(t,o)&&!e.o(n,o)&&Object.defineProperty(n,o,{enumerable:!0,get:t[o]})}}(),function(){e.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(n){if("object"===typeof window)return window}}()}(),function(){e.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)}}(),function(){var n={143:0};e.O.j=function(t){return 0===n[t]};var t=function(t,o){var i,r,a=o[0],s=o[1],c=o[2],d=0;if(a.some((function(t){return 0!==n[t]}))){for(i in s)e.o(s,i)&&(e.m[i]=s[i]);if(c)var f=c(e)}for(t&&t(o);d<a.length;d++)r=a[d],e.o(n,r)&&n[r]&&n[r][0](),n[r]=0;return e.O(f)},o=self["webpackChunkblog"]=self["webpackChunkblog"]||[];o.forEach(t.bind(null,0)),o.push=t.bind(null,o.push.bind(o))}();var o=e.O(void 0,[998],(function(){return e(2706)}));o=e.O(o)})();
//# sourceMappingURL=app.d0aefc08.js.map